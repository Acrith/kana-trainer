<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kana Learning Mode</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    #kanaStream {
      margin-bottom: 20px;
      font-size: 1.8rem;
    }
    .kana {
      color: #aaa;
      display: inline-block;
      text-align: center;
      width: 2em;
    }
    .active {
      font-weight: bold;
      color: #000;
    }
    .kana-hint {
      display: block;
      font-size: 0.7rem;
      color: #777;
    }
    #inputBox {
      font-size: 1.2rem;
      padding: 8px;
      width: 300px;
      margin-bottom: 10px;
    }
    .group-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 20px;
    }
    .group-block {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .group-label {
      font-size: 0.8rem;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .stat-kana {
      padding: 4px 6px;
      margin: 2px;
      font-size: 16px;
      border-radius: 4px;
      background: #eee;
      min-width: 28px;
      text-align: center;
      border: 1px solid #ccc;
    }
    .stat-kana.mastered {
      background: #c8f7c5;
      border-color: #4caf50;
    }
    .reveal-btn {
      margin-bottom: 10px;
      padding: 5px 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>üìò Kana Learning Mode</h1>
  <div id="modeInfo"></div>

  <div id="kanaStream"></div>
  <button class="reveal-btn" id="revealBtn">‚ùì Reveal Romaji (5s)</button>
  <input type="text" id="inputBox" placeholder="Type romaji..." autofocus />
  <p id="hint"></p>

  <div id="statsGrid" class="group-bar"></div>

  <p><a href="learn.html">üîô Back to mode select</a></p>

  <script type="module">
    import {
      HIRAGANA, KATAKANA,
      HIRAGANA_GROUPS, KATAKANA_GROUPS
    } from './kana-data.js';
    import { updateStats } from './storage.js';

    const inputBox = document.getElementById('inputBox');
    const kanaStream = document.getElementById('kanaStream');
    const statsGrid = document.getElementById('statsGrid');
    const hintEl = document.getElementById('hint');
    const revealBtn = document.getElementById('revealBtn');
    const modeEl = document.getElementById('modeInfo');

    const mode = new URLSearchParams(location.search).get("mode") || "hiragana";
    const isHiragana = mode === "hiragana" || mode === "mixed";
    const isKatakana = mode === "katakana" || mode === "mixed";
    const unlockedKey = `unlockedGroups_${mode}`;
    const LEARNING_SEQUENCE = [
      "vowels", "k", "s", "t", "n", "h", "m", "y", "r", "w", "g", "z", "d", "b", "p"
    ];

    const GROUPS = {
      hiragana: HIRAGANA_GROUPS,
      katakana: KATAKANA_GROUPS
    };
    const KANA = {
      hiragana: HIRAGANA,
      katakana: KATAKANA
    };

    modeEl.textContent = `üß≠ Mode: ${mode.toUpperCase()}`;

    let unlockedGroups = JSON.parse(localStorage.getItem(unlockedKey) || '["vowels"]');
    let kanaMap = {};
    let kanaKeys = [];

    if (isHiragana) unlockedGroups.forEach(g =>
      GROUPS.hiragana[g]?.forEach(k => {
        kanaMap[k] = HIRAGANA[k];
        kanaKeys.push(k);
      })
    );
    if (isKatakana) unlockedGroups.forEach(g =>
      GROUPS.katakana[g]?.forEach(k => {
        kanaMap[k] = KATAKANA[k];
        kanaKeys.push(k);
      })
    );

    let queue = [], currentKana = '', expectedRomaji = '', mistakeCount = 0;
    const sessionStats = {};
    const correctHistory = {};
    let revealTimer = null;
    let revealActive = false;

    function getRandomKana() {
      return kanaKeys[Math.floor(Math.random() * kanaKeys.length)];
    }

    function initQueue() {
      queue = [];
      for (let i = 0; i < 10; i++) queue.push(getRandomKana());
      renderQueue();
      setCurrent();
      renderStatsGrid();
    }

    function renderQueue() {
      kanaStream.innerHTML = '';
      queue.forEach((kana, i) => {
        const span = document.createElement('span');
        const romaji = kanaMap[kana];
        const stat = sessionStats[kana] || { correct: 0, incorrect: 0, shown: 0 };
        const total = stat.correct + stat.incorrect;

        stat.shown = (stat.shown || 0) + 1;
        sessionStats[kana] = stat;

        const showHint =
          revealActive || stat.shown <= 3 || stat.incorrect > 0;

        span.className = 'kana' + (i === 0 ? ' active' : '');
        span.innerHTML = `${showHint ? `<span class="kana-hint">${romaji}</span>` : ''}${kana}`;
        kanaStream.appendChild(span);
      });
    }

    function setCurrent() {
      currentKana = queue[0];
      expectedRomaji = kanaMap[currentKana];
      mistakeCount = 0;
      hintEl.textContent = '';
    }

    function isMastered(kana) {
      const history = correctHistory[kana] || [];
      if (history.length < 5) return false;
      return history.slice(-5).every(Boolean);
    }

    function checkUnlock() {
      const allSeen = new Set(Object.keys(sessionStats));
      for (const group of unlockedGroups) {
        let groupKana = [];
        if (isHiragana) groupKana.push(...(GROUPS.hiragana[group] || []));
        if (isKatakana) groupKana.push(...(GROUPS.katakana[group] || []));
        const seenKana = groupKana.filter(k => allSeen.has(k));
        const allMastered = seenKana.every(k => isMastered(k));
        if (!allMastered) return;
      }
      const nextGroup = LEARNING_SEQUENCE.find(g => !unlockedGroups.includes(g));
      if (nextGroup) {
        unlockedGroups.push(nextGroup);
        localStorage.setItem(unlockedKey, JSON.stringify(unlockedGroups));
        alert(`üéâ Unlocked: ${nextGroup.toUpperCase()}`);
        location.reload();
      }
    }

    function renderStatsGrid() {
      statsGrid.innerHTML = '';
      const groupData = {};
      if (isHiragana) unlockedGroups.forEach(g => groupData[g] = GROUPS.hiragana[g]);
      if (isKatakana) unlockedGroups.forEach(g => groupData[g] = GROUPS.katakana[g]);

      for (const [group, list] of Object.entries(groupData)) {
        const block = document.createElement('div');
        block.className = 'group-block';

        const label = document.createElement('div');
        label.className = 'group-label';
        label.textContent = group.toUpperCase();
        block.appendChild(label);

        (list || []).forEach(kana => {
          const span = document.createElement('span');
          span.className = 'stat-kana';
          const stat = sessionStats[kana] || { correct: 0, incorrect: 0 };
          const total = stat.correct + stat.incorrect;
          const text = `${kana} (${stat.correct}/${total})`;
          span.textContent = text;
          if (isMastered(kana)) span.classList.add('mastered');
          block.appendChild(span);
        });

        statsGrid.appendChild(block);
      }
    }

    inputBox.addEventListener('input', () => {
      const typed = inputBox.value.trim().toLowerCase();
      if (expectedRomaji.startsWith(typed)) {
        inputBox.className = 'correct';
        if (typed === expectedRomaji) {
          sessionStats[currentKana] = sessionStats[currentKana] || { correct: 0, incorrect: 0 };
          sessionStats[currentKana].correct++;
          correctHistory[currentKana] = (correctHistory[currentKana] || []).concat(true).slice(-5);
          updateStats(currentKana, true, 0);
          queue.shift();
          queue.push(getRandomKana());
          renderQueue();
          setCurrent();
          inputBox.value = '';
          renderStatsGrid();
          checkUnlock();
        }
      } else {
        mistakeCount++;
        sessionStats[currentKana] = sessionStats[currentKana] || { correct: 0, incorrect: 0 };
        sessionStats[currentKana].incorrect++;
        correctHistory[currentKana] = (correctHistory[currentKana] || []).concat(false).slice(-5);
        updateStats(currentKana, false, 0);
        inputBox.className = 'incorrect';
        inputBox.value = '';
        if (mistakeCount >= 3) hintEl.textContent = `üí° Hint: ${expectedRomaji[0]}_`;
        renderStatsGrid();
      }
    });

    revealBtn.addEventListener('click', () => {
      if (revealTimer) return;
      revealActive = true;
      renderQueue();
      revealBtn.disabled = true;
      revealTimer = setTimeout(() => {
        revealActive = false;
        renderQueue();
        revealBtn.disabled = false;
        revealTimer = null;
      }, 5000);
    });

    initQueue();
  </script>
</body>
</html>
